import numpy as np, matplotlib.pyplot as plt, time, re

ListOfTimes = []
userinput   = []
first_row   = []
arg3int = []
arg2int = []
arg1int = []
arg1 = []
arg2 = []
arg3 = [] 
#Values20Plus = [] #need to declare cuz otherwise gets arbitrarily large due to generator
firstvar  = ""
secondvar = ""
thirdvar  = ""
fourthvar = ""
plotagainst = ""

class CsvParsing(object):
    
    def __init__(self, ListOfVars, filename):
        self.ListOfVars = ListOfVars
        self.filename   = filename
        
        
    def tail(self):#defines a generator function for a file object and reader object
        #print "In tail"
        self.fileobj.seek(0,0) 
        TimeToBreak1 = StartTime = time.time()
        count = 0
        while not self.fileobj.closed:
            #print "111111111111111111"
            line = self.fileobj.readline()
            if not line:
                time.sleep(0.03)
                TimeToBreak2 = time.time()
                if TimeToBreak2 - TimeToBreak1 < 2: 
                    #this keeps track of how long a document hasnt been updated 
                    # i.e. how long a line hasnt been added
                    #print "TIME <2"
                    continue
                elif 2 <= TimeToBreak2 - TimeToBreak1<=5: #if wait for 2-5 sec more than 20 times - break
                    #print "2< TIME <5"
                    time.sleep(0.2)
                    count+=1
                    if count<20:
                        continue
                    else:
                        break
                else: #if wait more than 5 sec break because prob run out of lines in a file
                    break
            else:
                TimePassed = time.time()
                TimeStep   = abs(StartTime - TimePassed)
                #this tracks how long it takes to read another line
                ListOfTimes.append(TimeStep)
                yield line
                TimeToBreak1 = StartTime = time.time()

            AverageTime = np.mean(ListOfTimes)#MODIFY ST COMPUTES LAST ENTRIES or some subset 
            if AverageTime *10000 > 43200: # 12*60*60 seconds in 12 hrs; 10k cycles; crude calculation
                break 
            if np.mean(self.LinesInterval(ListOfTimes,20)) > 2:
                break # break if the last 20 time intervals are longer than 2 sec
        
        
    def ExtractArgs(self, generator): 
        ListOfVars = self.ListOfVars
        #print "In ExtractArgs"
        # the FIRST argument in ListOfVars should be the one to plot against
        #this generator will return a tuple of indep and dep vars
        # generator arg should be tail or something that continiously yields lines
        count1    = 0 #probably can set count because the first scope to search would be local within generator
        IndexList = [] # list of indices (natural #) to extract arguments that are in ListOfVars
        switch    = False
        for line in generator:
            #print line
            count1+=1
            lineSub  = re.sub(r' ', ",", line)
            #Returns the string obtained by replacing the leftmost non-overlapping occurrences of pattern by repl
            LineList = lineSub.split(",") #transforms line, possibly with commas into a list with
            #fields as members
            for field in LineList:
                LineList[LineList.index(field)] = field.replace(" ","") #strip fields of whitespaces
            if count1 == 1:
                for field in ListOfVars:
                    index = LineList.index(field)
                    IndexList.append(index)
                    #gets indices for desired variables in LineList and puts them into IndexList
            #print LineList, IndexList
            DesiredArgs = [] #set to empty to fill with current set of data points as strings
            for index in IndexList:
                DesiredArgs.append(LineList[index])
            for i in range(len(DesiredArgs)):
                try:
                    DesiredArgs[i] = int(float(DesiredArgs[i]))
                    switch = True
                    #print DesiredArgs
                except ValueError:
                    switch = False
                    continue
            DesiredArgs = tuple(DesiredArgs) #tuple of strings
            if switch == True:
                yield DesiredArgs #the desired tuple including the one to print against
                
                
    def ProcessingPairs(self, generator, argnum = 1, n = 30): #will consider gradient when have at leat n data points
        #argnum is the order of the argument in a tuple for which we want to compute the gradient, st from 0
        #MODIFY TO TAKE A LIST OF ARGS AS INPUT TO PROCESS
        #print "In ProcessingPairs"
        Values20Plus = []
        count2       = 0
        for seq in generator: #in ExtractArgs
            count2 +=1

            if len(Values20Plus) > 150:
                #these are all the same length and we dont want them to get too big, cuz these are lists
                Values20Plus = []
                Gradient     = []

            Values20Plus.append(seq[argnum]) # this list grows larger and larger every time prog is run
            #if we do not declare it as an empty list at the beginning
            #because gen keep on adding to it even after break command and on then next run of code

            if len(Values20Plus) < n:
                continue
            else:
                Gradient = np.gradient(Values20Plus, 10) 
                #computes a list of gradients which gets larger every time we iterate the loop
                #so want to extract the last 20 elements from this list
                print Gradient
                Means = self.ComputeMeanGrad(self.LastLineSplit(Gradient,n))
                if Means[0] < 2 and Means[1] < 2:
                    print "can consider termination"
                    DistOfMeans = self.CompareMeanGrad(Gradient,n)
                    if DistOfMeans <= 0.06: # was 0.05 for non abs grad
                        #this is deliberately too small s.t. it doesnt terminate
                        print "can terminate"
                        print DistOfMeans, "DistOfMeans"
                        break
                    else:
                        #print "keep computing"
                        yield DistOfMeans
                else:
                    print "cannot consider termination yet"
                    print Means, "Means split unequally"
                    continue

                    
    def LastLineSplit(self, list1, n):
        #print "In LastLineSplit"
        LastN_Entries = list1[-n:]
        i = 2*n/3
        j = n/3
        First23 = LastN_Entries[:i]
        Last13  = LastN_Entries[-j:]
        #returns two lists
        return First23, Last13 
    
    
    def LinesInterval(self, list1, n, m = None):
        #print "In LinesInterval"
        ListLast = list1[-n:m]
        return ListLast
    
    
    def ComputeMeanGrad(self, InpPair):
        #acts on LastLineSplit, a tuple of two unequal lengths lists
        # this checks whether abs vals of the tail and head are less than 2, if so can consider termination
        for i in range(len(InpPair[0])):
            InpPair[0][i] = abs(InpPair[0][i])
        for i in range(len(InpPair[1])):
            InpPair[1][i] = abs(InpPair[1][i])
        #converts gradient values to abs values
        mean1 = np.mean(InpPair[0])
        mean2 = np.mean(InpPair[1])
        return mean1, mean2
        
        
    def CompareMeanGrad(self, list1, n):
        #acts on Gradient, splits in half
        Half1 = self.LinesInterval(self.LinesInterval(list1, n), 0, int(math.floor(n/2))) #first n/2 elements
        Half2 = self.LinesInterval(self.LinesInterval(list1, n), int(math.floor(-n/2)))
        for i in range(len(Half1)):
            Half1[i] = abs(Half1[i])
        for i in range(len(Half2)):
            Half2[i] = abs(Half2[i])
        mean1 = np.mean(Half1)
        mean2 = np.mean(Half2)
        return abs(mean1 - mean2)
    
   
    def OpenFile(self):
        with open(self.filename, 'r') as fileobj:
            self.fileobj   = fileobj
            GeneratorTail  = self.tail()
            ExtractedArgs  = self.ExtractArgs(GeneratorTail)
            GetDistOfMeans = self.ProcessingPairs(ExtractedArgs)
            for i in GetDistOfMeans:
                print i 
                
            """maximum1 = max(ListOfTimes)
            #for some reason the greatest value for time interval is for the last line
            ListOfTimes.pop(len(ListOfTimes)-1)
            maximum2 = max(ListOfTimes)
            print ListOfTimes
            print maximum1, maximum2"""
            
x = CsvParsing(["Cycle","rhoV[0]","rhoV[1]"],'/Users/nikita.zabolotniy/Desktop/CSVtoWrite.txt')
x.OpenFile()


