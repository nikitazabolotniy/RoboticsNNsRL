import numpy as np, matplotlib.pyplot as plt, time, re, math, os, random

GlobalSwitch    = True
ListDesiredArgs = []
ListOfTimes     = [] 

class CsvParsing(object):
    
    def __init__(self, ListOfVars, filename):
        self.ListOfVars = ListOfVars
        self.filename   = filename
        
        
    def tail(self):
    
        global ListOfTimes
        ListOfTimes  = []
        TimeToBreak1 = StartTime = time.time()
        count        = 0
        self.fileobj.seek(0,0) 
        
        while not self.fileobj.closed:
            line = self.fileobj.readline()
            
            if not line:
                time.sleep(0.03)
                TimeToBreak2 = time.time()
                
                if TimeToBreak2 - TimeToBreak1 < 2: 
                    #this keeps track of how long a document hasnt been updated 
                    # i.e. how long a line hasnt been added
                    #print "TIME <2"
                    continue
                elif 2 <= TimeToBreak2 - TimeToBreak1 <= 5: 
                    #if loop over this for 20 times, ie there is no line 20 times, break
                    #can augment this bit do add conditions for termination, e.g. renew TimeToBreak1
                    time.sleep(0.2)
                    count += 1
                    
                    if count < 20:
                        continue
                    else:
                        break
                        
                else: #if wait more than 5 sec break because prob run out of lines in a file
                    break
                    
            else:
                #this tracks how long it takes to read another line
                TimePassed = time.time()
                TimeStep   = abs(StartTime - TimePassed)
                ListOfTimes.append(TimeStep)
                TimeToBreak1 = StartTime = time.time()
                yield line
                

            AverageTime = np.mean(ListOfTimes)
            if AverageTime * 10000 > 43200: # 12*60*60 seconds in 12 hrs; 10k cycles; crude calculation
                break 
            if np.mean(self.LinesInterval(ListOfTimes,20)) > 2:
                break # break if the last 20 time intervals are longer than 2 sec
            #TBD predict runtime, might be based on second derivatives
        
        
    def ExtractArgs(self, generator): 
        
        global GlobalSwitch
        ListOfVars   = self.ListOfVars #list of variables to plot, and the first one is to plot against
        GlobalSwitch = True 
        count1       = 0 
        IndexList    = [] # list of indices, to extract arguments that are in ListOfVars
        switch_1     = False
        switch_2     = True
        
        for line in generator:
            lineSub  = re.sub(r' ', ",", line)
            LineList = lineSub.split(",") #transforms line, possibly with commas into a list with
            #fields as members
            for field in LineList:
                LineList[LineList.index(field)] = field.replace(" ","") 
                
            if switch_2 == True:
                for field in ListOfVars: #this determines the length of IndexList and hence DesiredArgs
                    index    = LineList.index(field)
                    IndexList.append(index)
                    #gets indices for desired variables in LineList and puts them into IndexList
                    switch_2 = False
                    
            DesiredArgs = [] #set to empty to fill with current set of data points as strings
            
            for index in IndexList:
                DesiredArgs.append(LineList[index])
                
            for i in range(len(DesiredArgs)):
                try:
                    DesiredArgs[i] = float(DesiredArgs[i])
                    switch_1 = True
                except ValueError:
                    switch_1 = False
                    continue
                    
            DesiredArgs = tuple(DesiredArgs) #tuple of strings
            
            if GlobalSwitch and switch_1 == True:
                ListDesiredArgs.append(DesiredArgs) #list of tuples of desired args for plotting
            else: 
                print "SWITCHED"
                
            if switch_1 == True:
                yield DesiredArgs #the desired tuple including the one to print against
                
                
    def ProcessingPairs(self, generator, argnum = 1, n = 30): #will consider gradient when have at leat n data points
        #argnum is the order of the argument in a tuple for which we want to compute the gradient, st from 0
        #MODIFY TO TAKE A LIST OF ARGS AS INPUT TO PROCESS
        #print "In ProcessingPairs"
        
        global TimeStep
        Values20Plus = []
        TimeStep     = 0 #steps for computing derivatives
        count2       = 0
        #Step20Plus   = [] #steps for computing the gradient
        
        for a_tuple in generator: #in ExtractArgs
            count2 += 1
            if len(Values20Plus) > 150:
                #these are all the same length and we dont want them to get too big, cuz these are lists
                Values20Plus = []
                Gradient     = []

            Values20Plus.append(a_tuple[argnum])
            
            if count2 == 1:
                FirstVal  = 0
                SecondVal = 0
            if count2 == 2:
                FirstVal  = a_tuple[0]
            if count2 == 3:
                SecondVal = a_tuple[0]
                TimeStep  = SecondVal - FirstVal

            if len(Values20Plus) < n:
                continue
            else:
                Gradient = np.gradient(Values20Plus, TimeStep) 
                #computes a list of gradients which gets larger every time we iterate the loop
                #so want to extract the last n elements from this list
                print Gradient, "Gradient", len(Gradient)
                
                Means    = self.ComputeMeanGrad(self.LastLineSplit(Gradient,n))
                #splits the last n elements of gradient into tow unequal parts, tail is shorter
                
                if Means[0] < 2 and Means[1] < 2:
                    print "can consider termination", Means
                    
                    DistOfMeans = self.CompareMeanGrad(Gradient,n)
                    GradRatio , means  = self.CompareGradRatio(Gradient,n)
                    
                    print GradRatio, "GradRatio", means, "means"
                    
                    if DistOfMeans <= 0.1: # was 0.05 for non abs grad
                        #this is deliberately too small s.t. it doesnt terminate
                        print "can terminate"
                        print DistOfMeans, "DistOfMeans"
                        global GlobalSwitch
                        GlobalSwitch   = False # stop adding values to argints
                        break
                    else:
                        #print "keep computing"
                        yield DistOfMeans
                        
                else:
                    print "cannot consider termination yet"
                    print Means, "Means split unequally"
                    continue

                    
    def LastLineSplit(self, list1, n):
        #print "In LastLineSplit"
        LastN_Entries = list1[-n:]
        i = 2*n/3
        j = n/3
        First23 = LastN_Entries[:i]
        Last13  = LastN_Entries[-j:]
        #returns two lists
        return First23, Last13 
    
    
    def LinesInterval(self, list1, n, m = None):
        #print "In LinesInterval"
        ListLast = list1[-n:m]
        return ListLast
    
    
    def ComputeMeanGrad(self, InpPair):
        #acts on LastLineSplit, a tuple of two unequal lengths lists
        # this checks whether abs vals of the tail and head are less than 2, if so can consider termination
        for i in range(len(InpPair[0])):
            InpPair[0][i] = abs(InpPair[0][i])
        for i in range(len(InpPair[1])):
            InpPair[1][i] = abs(InpPair[1][i])  
        #converts gradient values to abs values
        mean1 = np.mean(InpPair[0])
        mean2 = np.mean(InpPair[1])
        return mean1, mean2
        
        
    def CompareMeanGrad(self, list1, n):
        #acts on Gradient, splits in half
        Half1 = self.LinesInterval(self.LinesInterval(list1, n), 0, int(math.floor(n/2))) #first n/2 elements
        Half2 = self.LinesInterval(self.LinesInterval(list1, n), int(math.floor(-n/2)))
        for i in range(len(Half1)):
            Half1[i] = abs(Half1[i])
        for i in range(len(Half2)):
            Half2[i] = abs(Half2[i])
        mean1 = np.mean(Half1)
        mean2 = np.mean(Half2)
        return abs(mean1 - mean2)
    
    def CompareGradRatio(self, list1, n):
        #this doesnt seem to be a good predictor because the range of values it takes is too wide with
        #the current algorithm. Moreover, it may not be relible for large values of gradient 
        #because its a ratio; even tho we consider last values, sudden jumps may trick it
        #strangely enough, its value before termination it quite small most of the times 
        #acts on Gradient, splits in half
        Half1 = self.LinesInterval(self.LinesInterval(list1, n), 0, int(math.floor(n/2))) #first n/2 elements
        Half2 = self.LinesInterval(self.LinesInterval(list1, n), int(math.floor(-n/2)))
        mean1 = np.mean(Half1)
        mean2 = np.mean(Half2)
        return mean2/mean1, (mean2, mean1)
            
    
    def OpenFile(self):
        with open(self.filename, 'r') as fileobj:
            self.fileobj   = fileobj
            GeneratorTail  = self.tail()
            ExtractedArgs  = self.ExtractArgs(GeneratorTail)
            GetDistOfMeans = self.ProcessingPairs(ExtractedArgs)
            for i in GetDistOfMeans:
                print i, "GetDistOfMeans"
            maximum1 = max(ListOfTimes)
            print maximum1, "maximum time"
            
            
    def Plot(self, ListOfTuples): #will act on a list of tuples of arguments
        ListOfVars = self.ListOfVars
        UnzipList  = zip(*ListOfTuples) #long tuples of values for args
        plt.figure(2, figsize=(6, 4), dpi=140, facecolor='w', edgecolor='k')
        for i in range(len(UnzipList) - 1):
            plt.plot(UnzipList[0], UnzipList[i+1], label = ListOfVars[i+1])
        plt.ylabel("Value") 
        plt.xlabel(ListOfVars[0])
        plt.legend()
        plt.show()
        
        covar = np.corrcoef([UnzipList[1], UnzipList[2]])
        print covar
        
        global ListDesiredArgs #empty ListDesiredArgs to be filled for future plotting
        ListDesiredArgs = []
        
        
    def FileNamesGen(self, dirname): #extracts and yields filenames from a directory, .csv and .txt
        time1 = time.time()
        for dirpath, subdirs, filenames in os.walk(dirname): #os.walk is a generator
            if filenames != []:
                for name in filenames:
                    if ".txt" in name or ".csv" in name:
                        yield os.path.join(dirpath,name)
                        #augment to make more flexible
            else:
                print "no files in a directory"
                time2 = time.time()
                if time2 - time1 < 5:
                    continue
                else:
                    break
    
    
    def OpenFileForVars(self, filenameForVars): #extracts names of variable to iterate over for gradient
        # and choose a random name as a third member of the list of names
        with open(filenameForVars, 'r') as fileobj:
            line     = fileobj.readline()
            lineSub  = re.sub(r' ', ",", line)
            LineList = lineSub.split(",") 
            
            for field in LineList:
                LineList[LineList.index(field)] = field.replace(" ","") 
            ListOfFields = list(LineList) #creates a copy of LineList
            
            for field in LineList:
                if field   == "":
                    ListOfFields.remove("")
                elif field == "\n":
                    ListOfFields.remove("\n")
                elif field == "Cycle":
                    ListOfFields.remove("Cycle")
                elif field == "RealTimeStep":
                    ListOfFields.remove("RealTimeStep")
                    
            RandomField = random.choice(ListOfFields)
            return RandomField, ListOfFields
            
            
DummyInstance = CsvParsing(["Cycle","rho", "rhoV[0]"], "dummy instance to use function")

path = "/Users/nikita.zabolotniy/Desktop/Directory_2" 

GenFilenames = DummyInstance.FileNamesGen(path)     

for filename in GenFilenames:
    RandomField, ListOfFields = DummyInstance.OpenFileForVars(filename) #open file to get variable names
    #for gradient computation for all variables along with one randomly selected extra variable to plot
    #then will again open the same file for processing
    for i in ListOfFields:
        x = CsvParsing(["Cycle", i, RandomField], filename)
        x.OpenFile()
        x.Plot(ListDesiredArgs)
    
#TBD ADD CODE TO CHECK WHETHER N IS DIV BY 3 ETC

"""a = list(ListOfFields)
for i in itertools.islice(list(ListOfFields), 3, len(ListOfFields) - 1):
    x = CsvParsing(["Cycle", i, "wall_Fx"],'/Users/nikita.zabolotniy/Desktop/ai4cfd_N0012_AoA0p0_Mach0p01_Re1000000p0_0_report.restart.csv')
    x.OpenFile()
    x.Plot(ListDesiredArgs)
a = []"""
